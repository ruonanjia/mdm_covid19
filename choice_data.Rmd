---
title: "R Notebook"
author: "ruonanjia"
output:
  pdf_document: default
  html_notebook: default
---
load library
```{r}
library(ggplot2)
library(ggpubr)
```


functions
```{r}
data_summary <- function(data, varname, groupnames){
  # Function to calculate the mean and the standard error
  # for each group
  #+++++++++++++++++++++++++
  # data : a data frame
  # varname : the name of a column containing the variable
  #to be summariezed
  # groupnames : vector of column names to be used as
  # grouping variables
  
  require(plyr)
  summary_func <- function(x, col){
    c(mean = mean(x[[col]], na.rm=TRUE),
      sd = sd(x[[col]], na.rm=TRUE)/sqrt(length(x[[col]])))
  }
  data_sum<-ddply(data, groupnames, .fun=summary_func,
                  varname)
  data_sum <- rename(data_sum, c("mean" = varname))
  return(data_sum)
}


data_meanstd <- function(x) {
  # Function to produce summary statistics (mean and +/- sd)
  m <- mean(x)
  ymin <- m-sd(x)
  ymax <- m+sd(x)
  return(c(y=m,ymin=ymin,ymax=ymax))
}

data_meanse <- function(x) {
  # Function to produce summary statistics (mean and +/- sd)
  m <- mean(x)
  ymin <- m-sd(x)/sqrt(length(x))
  ymax <- m+sd(x)/sqrt(length(x))
  return(c(y=m,ymin=ymin,ymax=ymax))
}

```


load data
```{r}
# setwd("E:/Ruonan/Projects in the lab/mdm_covid19/batch_data")
setwd("/Users/jiaruonan/Desktop/mdm_covid19/mdm_covid19_data")
load("data_all_444sub_rename.Rda")
load("data_all_444sub_rename_header.Rda")
trial.param <- read.csv("trialsinfo_COVID_19.csv", header = TRUE, )
```


task data
```{r}
# colnames(data.all)
# colnames(data.all)[c(29:41,43:54,56:79,89:101,103:113,115:139,140:149,151:154,353)]
# choice, rating, and ambiguity estimation
data.task <- data.all[,c(29:41,43:54,56:79,89:101,103:113,115:139,140:149,151:154,353)]
# View(data.task)
# colnames(data.task)
# change column names for ambiguity estimation
# colnames(data.task)[109:112] <- c("a24.e", "a50.e", "a74.e", "a100.e")
# colnames(data.task)

```

extract choice data
```{r}
# extract choice data and attache trial parameters
# concatenate all subjects

# colnames(trial.param)
# colnames(data.task)

for (i in 1:nrow(data.task)) {
  # single subject choice
  sub.choice <- trial.param
  choice <- data.task[i, 1:98]
  id <- data.task$mTurkCode[i] # MTurk code
  sub.choice$id <- id
  sub.choice$choice <- as.numeric(t(choice)) # transpose
  
  # concatenate
  if (i == 1) {
    data.choice <- sub.choice
  } else {
    data.choice <- rbind(data.choice, sub.choice)
  }
}

# View(data.choice)

# typeof(data.choice$val)

data.choice.mon <- data.choice[data.choice$is_med == 0, ]
data.choice.med <- data.choice[data.choice$is_med == 1, ]


data.choice.mon$val <- as.numeric(as.character(data.choice.mon$val))
data.choice.mon$prob <- as.factor(data.choice.mon$prob)
data.choice.mon$ambig <- as.factor(data.choice.mon$ambig)

data.choice.med$val <- as.factor(data.choice.med$val)
data.choice.med$prob <- as.factor(data.choice.med$prob)
data.choice.med$ambig <- as.factor(data.choice.med$ambig)
```

Plot average choice probability by uncertainty level
```{r}
# # monetary
# ggplot(data.choice.mon[data.choice.mon$id == id & data.choice.mon$ambig == 0, ], aes(x = val, y = choice, color = prob, fill = prob)) + 
#   geom_point(stat = "identity", size = 2, alpha = 0.6) +
#   geom_line()
# 
# ggplot(data.choice.mon[data.choice.mon$id == id & data.choice.mon$ambig != 0, ], aes(x = val, y = choice, color = ambig, fill = ambig)) + 
#   geom_point(stat = "identity", size = 2, alpha = 0.6) +
#   geom_line()
# 
# # medical
# ggplot(data.choice.med[data.choice.med$id == id & data.choice.med$ambig == 0, ], aes(x = val, y = choice, color = prob, fill = prob)) + 
#   geom_point(stat = "identity", size = 2, alpha = 0.6) +
#   scale_x_discrete(limits = c("Slight", "Moderate", "Major", "Recovery")) +
#   geom_line()

# typeof(data.choice.med$prob)

# monetary risky
data_plot <- data_summary(data.choice.mon[data.choice.mon$ambig == 0,], varname = "choice", groupnames = "prob")

ggplot(data_plot, aes(x=prob, y=choice)) +
  geom_bar(stat="identity", position=position_dodge()) +
  geom_errorbar(aes(ymin=choice-sd, ymax=choice+sd), width=0.2, position=position_dodge(0.9)) +
  ggtitle("Monetary Risky")

# monetary ambiguous
data_plot <- data_summary(data.choice.mon[data.choice.mon$ambig != 0,], varname = "choice", groupnames = "ambig")

ggplot(data_plot, aes(x=ambig, y=choice)) +
  geom_bar(stat="identity", position=position_dodge()) +
  geom_errorbar(aes(ymin=choice-sd, ymax=choice+sd), width=0.2, position=position_dodge(0.9)) +
  ggtitle("Monetary Ambiguous")

# medical risky
data_plot <- data_summary(data.choice.med[data.choice.med$ambig == 0,], varname = "choice", groupnames = "prob")

ggplot(data_plot, aes(x=prob, y=choice)) +
  geom_bar(stat="identity", position=position_dodge()) +
  geom_errorbar(aes(ymin=choice-sd, ymax=choice+sd), width=0.2, position=position_dodge(0.9)) +
  ggtitle("Medical Risky")

# medical ambiguous
data_plot <- data_summary(data.choice.med[data.choice.med$ambig != 0,], varname = "choice", groupnames = "ambig")

ggplot(data_plot, aes(x=ambig, y=choice)) +
  geom_bar(stat="identity", position=position_dodge()) +
  geom_errorbar(aes(ymin=choice-sd, ymax=choice+sd), width=0.2, position=position_dodge(0.9)) +
  ggtitle("Medical Ambiguous")


```

plot average choice probability by value
```{r}
# monetary risky
data_plot <- data_summary(data.choice.mon[data.choice.mon$ambig == 0,], varname = "choice", groupnames = "val")

ggplot(data_plot, aes(x=val, y=choice)) +
  geom_bar(stat="identity", position=position_dodge()) +
  geom_errorbar(aes(ymin=choice-sd, ymax=choice+sd), width=0.2, position=position_dodge(0.9)) +
  scale_x_discrete(limits = c(5,8,12,25)) +
  ggtitle("Monetary Risky")

# monetary ambiguous
data_plot <- data_summary(data.choice.mon[data.choice.mon$ambig != 0,], varname = "choice", groupnames = "val")

ggplot(data_plot, aes(x=val, y=choice)) +
  geom_bar(stat="identity", position=position_dodge()) +
  geom_errorbar(aes(ymin=choice-sd, ymax=choice+sd), width=0.2, position=position_dodge(0.9)) +
  scale_x_discrete(limits = c(5,8,12,25)) +
  ggtitle("Monetary Ambiguous")

# medical risky
data_plot <- data_summary(data.choice.med[data.choice.med$ambig == 0,], varname = "choice", groupnames = "val")

ggplot(data_plot, aes(x=val, y=choice)) +
  geom_bar(stat="identity", position=position_dodge()) +
  geom_errorbar(aes(ymin=choice-sd, ymax=choice+sd), width=0.2, position=position_dodge(0.9)) +
  scale_x_discrete(limits = c("Slight", "Moderate", "Major", "Recovery")) +
  ggtitle("Medical Risky")

# medical ambiguous
data_plot <- data_summary(data.choice.med[data.choice.med$ambig != 0,], varname = "choice", groupnames = "val")

ggplot(data_plot, aes(x=val, y=choice)) +
  geom_bar(stat="identity", position=position_dodge()) +
  geom_errorbar(aes(ymin=choice-sd, ymax=choice+sd), width=0.2, position=position_dodge(0.9)) +
  scale_x_discrete(limits = c("Slight", "Moderate", "Major", "Recovery")) +
  ggtitle("Medical Ambiguous")
```


individual subject choice data
```{r}
# id_idx = 1
ids <- data.task$mTurkCode

for (id in ids) {
  
  # single subject data
  sub.mon <- data.choice.mon[data.choice.mon$id == id,]
  sub.med <- data.choice.med[data.choice.med$id == id,]
  sub.mon$val <- as.factor(sub.mon$val)
  
  sub.mon
}  
```  


individual subject choice data
```{r}
# id_idx = 1
ids <- data.task$mTurkCode

for (id in ids) {
  
  # single subject data
  sub.mon <- data.choice.mon[data.choice.mon$id == id,]
  sub.med <- data.choice.med[data.choice.med$id == id,]
  sub.mon$val <- as.factor(sub.mon$val)
  
  # monetary risky
  data_plot <- data_summary(sub.mon[sub.mon$ambig == 0,], varname = "choice", groupnames = c("val", "prob"))
  
  p1 <- ggplot(data_plot, aes(x=val, y=prob, fill=choice)) + 
    geom_tile(color = "white")+
    scale_x_discrete(breaks = c(5,8,12,25)) +
    scale_fill_gradient(limits = c(0,1)) +
    theme(panel.grid = element_blank(),
          panel.background = element_blank()) +
    ggtitle(paste("Monetary Risky, Sub", as.character(id))) +
    xlab("Value ($)") + ylab("Risk Level")
  
  # monetary ambiguous
  data_plot <- data_summary(sub.mon[sub.mon$ambig != 0,], varname = "choice", groupnames = c("val", "ambig"))
  
  p2 <- ggplot(data_plot, aes(x=val, y=ambig, fill=choice)) + 
    geom_tile(color = "white")+
    scale_x_discrete(breaks = c(5,8,12,25)) +
    scale_fill_gradient(limits = c(0,1)) +
    theme(panel.grid = element_blank(),
          panel.background = element_blank()) +
    ggtitle("Monetary Ambiguous") +
    xlab("Value ($)") + ylab("Ambiguity Level")
  
  # medical risky
  data_plot <- data_summary(sub.med[sub.med$ambig == 0,], varname = "choice", groupnames = c("val", "prob"))
  
  p3 <- ggplot(data_plot, aes(x=val, y=prob, fill=choice)) + 
    geom_tile(color = "white")+
    scale_x_discrete(limits = c("Slight", "Moderate", "Major", "Recovery")) +
    scale_fill_gradient(limits = c(0,1)) +
    theme(panel.grid = element_blank(),
          panel.background = element_blank()) +
    ggtitle("Medical Risky") +
    xlab("Outcome") + ylab("Risk Level")
  
  # medical ambiguous
  data_plot <- data_summary(sub.med[sub.med$ambig != 0,], varname = "choice", groupnames = c("val", "ambig"))
  
  p4 <- ggplot(data_plot, aes(x=val, y=ambig, fill=choice)) + 
    geom_tile(color = "white")+
    scale_x_discrete(limits = c("Slight", "Moderate", "Major", "Recovery")) +
    scale_fill_gradient(limits = c(0,1)) +
    theme(panel.grid = element_blank(),
          panel.background = element_blank()) +
    ggtitle("Medical Ambiguous") +
    xlab("Outcome") + ylab("Ambiguity Level")
  
  figure <- ggarrange(p1,p2,p3,p4,
                      ncol = 2, nrow = 2) + border(size = 2)

  print(figure)
  
  annotate_figure(figure,
                  top = text_grob(paste("MTurkCode", as.character(id)))
                  )

}
```


```{r}
# install.packages(c("devtools","mvtnorm","loo","coda", "dagitty"))
# install.packages("backports")
# library(devtools)
# devtools::install_github("rmcelreath/rethinking")

library(rethinking)
```


Behavioral fitting
```{r}
data.choice.mon$val <- data.choice.mon$val * 100

data.choice.mon$prob.ref <- 1 * rep(1, length(data.choice.mon$prob))
data.choice.mon$ambig.ref <- 0 * rep(1, length(data.choice.mon$prob))
data.choice.mon$val.ref <- 500 * rep(1, length(data.choice.mon$prob))

# make id: 1 ~ number of subjects
no_trials = sum(data.choice.mon$id == data.choice.mon$id[1])
data.choice.mon$subid = NaN

for (i in c(1:444) ) {
  data.choice.mon$subid[(1+no_trials*(i-1)):(no_trials*i)] <- t(rep(i, no_trials))
}

# data.choice.mon$id <-  as.integer(as.character(data.choice.mon$id))

data_list <- list(
  choice = as.numeric(as.character(data.choice.mon$choice)),
  prob = as.numeric(as.character(data.choice.mon$prob)),
  ambig = as.numeric(as.character(data.choice.mon$ambig)),
  val = as.numeric(as.character(data.choice.mon$val)),
  prob_ref = as.numeric(as.character(data.choice.mon$prob.ref)),
  ambig_ref = as.numeric(as.character(data.choice.mon$ambig.ref)),
  val_ref = as.numeric(as.character(data.choice.mon$val.ref)),
  id = as.integer(data.choice.mon$subid)
)

fit.choice.multi <- ulam(
  alist(
    choice ~ dbinom(1, choice_prob), # sample from bernoulli distribution
    logit(choice_prob) <- (uL-uR)/slope[id],
    # choice_prob <- 1 / (1 + exp(slope[id]*(uL-uR))), # choice probablity of the lottery
    uL <- (prob - beta[id] * (ambig/2)) * val ^alpha[id], # subjective value of the lottery
    uR <- (prob_ref - beta[id] * (ambig_ref/2)) * val_ref ^alpha[id], # subjective value of the reference
    
    # alpha[id] ~ dnorm(miu_a, sigma_a),
    # beta[id] ~ dnorm(miu_b, sigma_b),
    # slope[id] ~ dnorm(miu_s, sigma_s),
    
    alpha[id] ~ dnorm(1, 1),
    beta[id] ~ dnorm(0, 1),
    slope[id] ~ dnorm(-2, 3)
    
    # group level priors
    # miu_a ~ dnorm(1, 1),
    # sigma_a ~ dexp(1),
    # 
    # miu_b ~ dnorm(0, 1),
    # sigma_b ~ dexp(1),
    # 
    # miu_s ~ dnorm(-2, 3),
    # sigma_s ~ dexp(1),
  ), 
  data = data_list, iter = 1e3, chains=4,
  start = list(alpha = rep(1, 444), beta = rep(0, 444), sigma = rep(-2, 444))
)

# no multilevel
fit.choice <- ulam(
  alist(
    choice ~ dbinom(1, choice_prob), # sample from bernoulli distribution
    choice_prob <- 1 / (1 + exp(slope*(uL-uR))), # choice probablity of the lottery
    uL <- (prob - beta * (ambig/2)) * val ^alpha, # subjective value of the lottery
    uR <- (prob_ref - beta * (ambig_ref/2)) * val_ref ^alpha, # subjective value of the reference
    
    
    alpha ~ dnorm(1, 1),
    beta ~ dnorm(0, 1),
    slope ~ dnorm(-2, 3)
    
  ), 
  data = data_list, iter = 1e4, chains=4
)
```

Try quap
```{r}
fit.choice.quap <- quap(
  alist(
    choice ~ dbinom(1, choice_prob), # sample from bernoulli distribution
    choice_prob <- 1 / (1 + exp(slope[id]*(uL-uR))), # choice probablity of the lottery
    uL <- (prob - beta[id] * (ambig/2)) * val ^alpha[id], # subjective value of the lottery
    uR <- (prob_ref - beta[id] * (ambig_ref/2)) * val_ref ^alpha[id], # subjective value of the reference
    
    # alpha[id] ~ dnorm(miu_a, sigma_a),
    # beta[id] ~ dnorm(miu_b, sigma_b),
    # slope[id] ~ dnorm(miu_s, sigma_s),
    
    alpha[id] ~ dnorm(1, 1),
    beta[id] ~ dnorm(0, 1),
    slope[id] ~ dnorm(-2, 3)
    
    # group level priors
    # miu_a ~ dnorm(1, 1),
    # sigma_a ~ dexp(1),
    # 
    # miu_b ~ dnorm(0, 1),
    # sigma_b ~ dexp(1),
    # 
    # miu_s ~ dnorm(-2, 3),
    # sigma_s ~ dexp(1),
  ), 
  data = data_list
)
```




